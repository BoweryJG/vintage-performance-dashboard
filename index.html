<!DOCTYPE html>
<html>
<head>
    <title>Elite Performance Cockpit | Sales Command Center</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: radial-gradient(ellipse at center, #1a2332 0%, #0a0e14 100%);
            overflow: hidden;
            color: #D4AF37;
            cursor: none;
        }
        
        canvas {
            display: block;
            touch-action: none;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: linear-gradient(135deg, rgba(26, 35, 50, 0.95), rgba(10, 14, 20, 0.95));
            border: 2px solid #8B4513;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 
                0 0 20px rgba(212, 175, 55, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .hud-title {
            font-size: 14px;
            font-weight: 900;
            color: #D4AF37;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }
        
        .metric {
            font-size: 11px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            color: #C0C0C0;
        }
        
        .metric-value {
            color: #00FF41;
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }
        
        #environment-selector {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .env-btn {
            background: linear-gradient(135deg, #8B4513, #654321);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            font-family: 'Orbitron', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        
        .env-btn:hover, .env-btn.active {
            background: linear-gradient(135deg, #D4AF37, #FFD700);
            color: #000;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.7);
        }
        
        #performance-indicator {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            text-align: center;
        }
        
        .performance-ring {
            width: 80px;
            height: 80px;
            border: 3px solid #8B4513;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.1), transparent);
            position: relative;
            overflow: hidden;
        }
        
        .performance-value {
            font-size: 18px;
            font-weight: 900;
            color: #00FF41;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.8);
        }
        
        .custom-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #D4AF37;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: transform 0.1s ease;
        }
        
        /* Ferrari/Cartier Luxury Mobile Optimization */
        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }
            
            #hud {
                top: 5px;
                left: 5px;
                right: 5px;
                padding: 8px;
                font-size: 10px;
                width: auto;
                max-width: 200px;
            }
            
            .hud-title {
                font-size: 10px;
                margin-bottom: 5px;
                letter-spacing: 1px;
            }
            
            .metric {
                font-size: 9px;
                margin: 3px 0;
            }
            
            #environment-selector {
                bottom: 5px;
                left: 5px;
                right: 5px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .env-btn {
                padding: 4px 6px;
                margin: 1px;
                font-size: 8px;
                flex: 1;
                min-width: 60px;
            }
            
            #performance-indicator {
                top: 5px;
                right: 5px;
                transform: none;
            }
            
            .performance-ring {
                width: 60px;
                height: 60px;
                border-width: 2px;
            }
            
            .performance-value {
                font-size: 14px;
            }
        }
        
        @media (max-width: 480px) {
            #hud {
                max-width: 180px;
                padding: 6px;
            }
            
            .hud-title {
                font-size: 9px;
            }
            
            .metric {
                font-size: 8px;
            }
            
            .env-btn {
                font-size: 7px;
                padding: 3px 4px;
            }
            
            .performance-ring {
                width: 50px;
                height: 50px;
            }
            
            .performance-value {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="cursor"></div>
    
    <div id="hud">
        <div class="hud-title">âš¡ Elite Performance Cockpit</div>
        <div class="metric">
            <span>Revenue Velocity</span>
            <span class="metric-value" id="revenue-velocity">$847K/mo</span>
        </div>
        <div class="metric">
            <span>Quota Achievement</span>
            <span class="metric-value" id="quota-achievement">127%</span>
        </div>
        <div class="metric">
            <span>Pipeline Health</span>
            <span class="metric-value" id="pipeline-health">94%</span>
        </div>
        <div class="metric">
            <span>Win Rate</span>
            <span class="metric-value" id="win-rate">73%</span>
        </div>
        <div class="metric">
            <span>Activity Score</span>
            <span class="metric-value" id="activity-score">156</span>
        </div>
        <div class="metric">
            <span>Team Ranking</span>
            <span class="metric-value" id="team-ranking">#2</span>
        </div>
    </div>
    
    <div id="performance-indicator">
        <div class="performance-ring">
            <div class="performance-value" id="performance-value">87%</div>
        </div>
    </div>
    
    <div id="environment-selector">
        <button class="env-btn active" data-env="space">Deep Space</button>
        <button class="env-btn" data-env="ocean">Ocean Depths</button>
        <button class="env-btn" data-env="desert">Desert Highway</button>
        <button class="env-btn" data-env="forest">Forest Canopy</button>
        <button class="env-btn" data-env="tundra">Arctic Tundra</button>
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    <script>
        let scene, camera, renderer, dashboard, gauges = [], needles = [], currentEnvironment = 'space';
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        
        // Elite Performance Data with realistic goal-based ranges
        const performanceData = {
            revenueVelocity: { current: 87, target: 100, min: 50, max: 120, unit: 'K/mo' },
            quotaAchievement: { current: 127, target: 100, min: 60, max: 150, unit: '%' },
            pipelineHealth: { current: 94, target: 95, min: 70, max: 100, unit: '%' },
            winRate: { current: 73, target: 80, min: 40, max: 90, unit: '%' },
            activityScore: { current: 156, target: 150, min: 100, max: 200, unit: '' }
        };
        
        // Luxury Materials
        const materials = {
            leather: null,
            brushedAluminum: null,
            gold: null,
            glass: null
        };
        
        function init() {
            console.log('ðŸŽï¸ Initializing Elite Performance Cockpit');
            
            // Scene setup
            scene = new THREE.Scene();
            
            // Camera with cockpit perspective
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 8);
            
            // Renderer with premium quality
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Initialize materials
            initializeLuxuryMaterials();
            
            // Create environment
            createEnvironment('space');
            
            // Create dashboard
            createVintageDashboard();
            
            // Create gauges
            createPerformanceGauges();
            
            // Setup interactions
            setupInteractions();
            
            // Start dramatic load animation
            startDramaticLoadSequence();
            
            // Start animation
            animate();
            
            console.log('âœ¨ Elite Performance Cockpit Ready');
        }
        
        function initializeLuxuryMaterials() {
            // Vintage leather texture
            materials.leather = new THREE.MeshPhysicalMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1,
                clearcoat: 0.3,
                clearcoatRoughness: 0.7
            });
            
            // Brushed aluminum
            materials.brushedAluminum = new THREE.MeshPhysicalMaterial({
                color: 0xC0C0C0,
                roughness: 0.3,
                metalness: 0.9,
                emissive: 0x222222,
                emissiveIntensity: 0.05
            });
            
            // Luxury gold
            materials.gold = new THREE.MeshPhysicalMaterial({
                color: 0xFFD700,
                roughness: 0.1,
                metalness: 0.9,
                emissive: 0xFFD700,
                emissiveIntensity: 0.1
            });
            
            // Premium glass
            materials.glass = new THREE.MeshPhysicalMaterial({
                color: 0xFFFFFF,
                roughness: 0.0,
                metalness: 0.0,
                transparent: true,
                opacity: 0.1,
                transmission: 0.9,
                thickness: 0.5
            });
        }
        
        function createEnvironment(envType) {
            // Clear existing environment
            scene.children = scene.children.filter(child => !child.userData.isEnvironment);
            
            switch(envType) {
                case 'space':
                    createSpaceEnvironment();
                    break;
                case 'ocean':
                    createOceanEnvironment();
                    break;
                case 'desert':
                    createDesertEnvironment();
                    break;
                case 'forest':
                    createForestEnvironment();
                    break;
                case 'tundra':
                    createTundraEnvironment();
                    break;
            }
            
            currentEnvironment = envType;
        }
        
        function createSpaceEnvironment() {
            scene.background = new THREE.Color(0x000011);
            
            // Stars
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            
            for (let i = 0; i < 2000; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 2,
                sizeAttenuation: false
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.userData.isEnvironment = true;
            scene.add(stars);
            
            // Nebula effect
            const nebulaGeometry = new THREE.PlaneGeometry(1000, 1000);
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                color: 0x4169E1,
                transparent: true,
                opacity: 0.1
            });
            
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebula.position.z = -500;
            nebula.userData.isEnvironment = true;
            scene.add(nebula);
            
            // Ambient lighting for space
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1.2);
            ambientLight.userData.isEnvironment = true;
            scene.add(ambientLight);
            
            // Key light for gauges
            const keyLight = new THREE.DirectionalLight(0xFFFFFF, 2);
            keyLight.position.set(0, 10, 10);
            keyLight.userData.isEnvironment = true;
            scene.add(keyLight);
        }
        
        function createOceanEnvironment() {
            scene.background = new THREE.Color(0x003366);
            
            // Ocean floor
            const oceanFloor = new THREE.PlaneGeometry(2000, 2000);
            const oceanMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x004488,
                roughness: 0.1,
                metalness: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const floor = new THREE.Mesh(oceanFloor, oceanMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -100;
            floor.userData.isEnvironment = true;
            scene.add(floor);
            
            // Ambient ocean lighting
            const oceanLight = new THREE.AmbientLight(0x004488, 0.5);
            oceanLight.userData.isEnvironment = true;
            scene.add(oceanLight);
        }
        
        function createDesertEnvironment() {
            scene.background = new THREE.Color(0x8B4513);
            
            // Desert ground
            const desertGround = new THREE.PlaneGeometry(2000, 2000);
            const desertMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xD2B48C,
                roughness: 0.9,
                metalness: 0.0
            });
            
            const ground = new THREE.Mesh(desertGround, desertMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -50;
            ground.userData.isEnvironment = true;
            scene.add(ground);
            
            // Desert sun
            const sunLight = new THREE.DirectionalLight(0xFFD700, 1);
            sunLight.position.set(100, 100, 50);
            sunLight.userData.isEnvironment = true;
            scene.add(sunLight);
        }
        
        function createForestEnvironment() {
            scene.background = new THREE.Color(0x2F4F2F);
            
            // Forest ambient
            const forestLight = new THREE.AmbientLight(0x228B22, 0.4);
            forestLight.userData.isEnvironment = true;
            scene.add(forestLight);
        }
        
        function createTundraEnvironment() {
            scene.background = new THREE.Color(0xF0F8FF);
            
            // Tundra ground
            const tundraGround = new THREE.PlaneGeometry(2000, 2000);
            const tundraMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xF0F8FF,
                roughness: 0.5,
                metalness: 0.0
            });
            
            const ground = new THREE.Mesh(tundraGround, tundraMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -30;
            ground.userData.isEnvironment = true;
            scene.add(ground);
            
            // Cold light
            const coldLight = new THREE.AmbientLight(0xE0FFFF, 0.6);
            coldLight.userData.isEnvironment = true;
            scene.add(coldLight);
        }
        
        function createVintageDashboard() {
            // NO DASHBOARD - just floating gauges in space for now
            console.log('âœ“ Clean space environment - no dashboard blocking');
        }
        
        function createPerformanceGauges() {
            // Mobile-optimized luxury gauge layout
            const isMobile = window.innerWidth <= 768;
            const baseSize = isMobile ? 0.8 : 1.0;
            
            const gaugePositions = [
                { 
                    pos: [0, isMobile ? 1.5 : 1.2, 2], 
                    size: baseSize * 1.2, 
                    metric: 'revenueVelocity', 
                    label: 'REVENUE',
                    needleStart: -Math.PI * 0.6 // Lower left start
                },
                { 
                    pos: [isMobile ? -1.8 : -2.8, isMobile ? 0.2 : 0.3, 2], 
                    size: baseSize, 
                    metric: 'quotaAchievement', 
                    label: 'QUOTA',
                    needleStart: -Math.PI * 0.8 // Lower start
                },
                { 
                    pos: [isMobile ? 1.8 : 2.8, isMobile ? 0.2 : 0.3, 2], 
                    size: baseSize, 
                    metric: 'pipelineHealth', 
                    label: 'PIPELINE',
                    needleStart: -Math.PI * 0.4 // Lower right start
                },
                { 
                    pos: [isMobile ? -1.2 : -1.6, isMobile ? -1.2 : -1.0, 2], 
                    size: baseSize * 0.9, 
                    metric: 'winRate', 
                    label: 'WIN RATE',
                    needleStart: -Math.PI * 0.7 // Lower left start
                },
                { 
                    pos: [isMobile ? 1.2 : 1.6, isMobile ? -1.2 : -1.0, 2], 
                    size: baseSize * 0.9, 
                    metric: 'activityScore', 
                    label: 'ACTIVITY',
                    needleStart: -Math.PI * 0.5 // Lower right start
                }
            ];
            
            gaugePositions.forEach((config, index) => {
                createLuxuryGauge(config, index);
            });
        }
        
        function createGaugeFaceWithMetrics(config, data, index) {
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Ferrari/Cartier luxury gradient - deep black to platinum
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, '#1a1a1a');      // Deep charcoal center
            gradient.addColorStop(0.4, '#2d2d2d');    // Dark gray
            gradient.addColorStop(0.8, '#404040');    // Medium gray
            gradient.addColorStop(1, '#0d0d0d');      // Black edge
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Luxury platinum rim
            ctx.strokeStyle = '#E5E4E2';
            ctx.lineWidth = 8;
            ctx.shadowColor = '#E5E4E2';
            ctx.shadowBlur = 20;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Inner platinum accent ring
            ctx.strokeStyle = '#D4AF37';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2 * 0.85, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw goal-based tick marks and numbers
            const range = data.max - data.min;
            const targetPosition = (data.target - data.min) / range;
            
            for (let i = 0; i <= 8; i++) {
                const percentage = i / 8;
                const angle = -Math.PI * 0.75 + (Math.PI * 1.5 * percentage);
                const isMajor = i % 2 === 0;
                
                // Tick marks with luxury styling
                const tickStart = isMajor ? 0.72 : 0.78;
                const tickEnd = 0.88;
                const startX = size/2 + Math.cos(angle) * (size/2 * tickStart);
                const startY = size/2 + Math.sin(angle) * (size/2 * tickStart);
                const endX = size/2 + Math.cos(angle) * (size/2 * tickEnd);
                const endY = size/2 + Math.sin(angle) * (size/2 * tickEnd);
                
                // Gold accents for target area
                const isNearTarget = Math.abs(percentage - targetPosition) < 0.15;
                ctx.strokeStyle = isNearTarget ? '#D4AF37' : '#E5E4E2';
                ctx.lineWidth = isMajor ? (isNearTarget ? 4 : 3) : 1;
                ctx.shadowColor = isNearTarget ? '#D4AF37' : 'transparent';
                ctx.shadowBlur = isNearTarget ? 8 : 0;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Numbers for major ticks (goal-based range)
                if (isMajor) {
                    const value = Math.round(data.min + (range * percentage));
                    const labelRadius = 0.62;
                    const labelX = size/2 + Math.cos(angle) * (size/2 * labelRadius);
                    const labelY = size/2 + Math.sin(angle) * (size/2 * labelRadius);
                    
                    ctx.fillStyle = isNearTarget ? '#D4AF37' : '#E5E4E2';
                    ctx.font = 'bold 20px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = isNearTarget ? '#D4AF37' : 'transparent';
                    ctx.shadowBlur = isNearTarget ? 5 : 0;
                    ctx.fillText(value.toString(), labelX, labelY);
                    ctx.shadowBlur = 0;
                }
            }
            
            // Center area with luxury styling
            const currentValue = Math.round(data.current);
            
            // Deep center background
            ctx.fillStyle = 'rgba(0,0,0,0.9)';
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2 * 0.45, 0, Math.PI * 2);
            ctx.fill();
            
            // Platinum center ring
            ctx.strokeStyle = '#E5E4E2';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#E5E4E2';
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Performance-based value color (Ferrari red accent)
            let valueColor = '#FF2D00'; // Ferrari red default
            const targetDiff = Math.abs(currentValue - data.target);
            if (targetDiff <= 5) valueColor = '#D4AF37';      // Gold (on target)
            else if (targetDiff <= 15) valueColor = '#E5E4E2'; // Platinum (close)
            else if (currentValue > data.target) valueColor = '#32CD32'; // Green (exceeding)
            
            // Large current value with luxury styling
            ctx.fillStyle = valueColor;
            ctx.font = 'bold 56px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = valueColor;
            ctx.shadowBlur = 25;
            ctx.fillText(currentValue.toString(), size/2, size/2 - 15);
            
            // Unit symbol
            ctx.fillStyle = '#D4AF37';
            ctx.font = 'bold 20px Orbitron';
            ctx.shadowColor = '#D4AF37';
            ctx.shadowBlur = 10;
            ctx.fillText(data.unit, size/2, size/2 + 25);
            
            // Metric label with luxury styling
            ctx.fillStyle = '#E5E4E2';
            ctx.font = 'bold 16px Orbitron';
            ctx.shadowColor = '#E5E4E2';
            ctx.shadowBlur = 8;
            ctx.fillText(config.label, size/2, size/2 + 80);
            ctx.shadowBlur = 0;
            
            // Create texture and material
            const texture = new THREE.CanvasTexture(canvas);
            const faceMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true
            });
            
            const faceGeometry = new THREE.CircleGeometry(config.size, 64);
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            
            // Store references for updates
            face.userData = {
                isGaugeFace: true,
                metric: config.metric,
                canvas: canvas,
                ctx: ctx,
                texture: texture,
                config: config,
                index: index
            };
            
            return face;
        }

        function createLuxuryGauge(config, index) {
            const data = performanceData[config.metric];
            
            // Create gauge face with embedded metrics
            const face = createGaugeFaceWithMetrics(config, data, index);
            face.position.set(...config.pos);
            face.position.z += 0.02;
            face.receiveShadow = true;
            scene.add(face);
            
            // Luxury bezel with Ferrari/Cartier styling
            const luxuryColors = [0xE5E4E2, 0xD4AF37, 0xFF2D00, 0xE5E4E2, 0xD4AF37]; // Platinum, Gold, Ferrari Red
            const bezelGeometry = new THREE.TorusGeometry(config.size + 0.06, 0.02, 16, 64);
            const bezelMaterial = new THREE.MeshPhysicalMaterial({
                color: luxuryColors[index],
                emissive: luxuryColors[index],
                emissiveIntensity: 0.2,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
            bezel.position.set(config.pos[0], config.pos[1], config.pos[2]);
            bezel.position.z += 0.01;
            bezel.castShadow = true;
            scene.add(bezel);
            
            // Luxury Ferrari-style needle
            const needleLength = config.size * 0.65;
            const needleShape = new THREE.Shape();
            
            // Create elegant needle shape
            needleShape.moveTo(0, -0.02);           // Thin base left
            needleShape.lineTo(0, 0.02);            // Thin base right  
            needleShape.lineTo(needleLength, 0.003); // Ultra-fine point right
            needleShape.lineTo(needleLength, -0.003); // Ultra-fine point left
            needleShape.lineTo(0, -0.02);           // Back to start
            
            const needleGeometry = new THREE.ShapeGeometry(needleShape);
            const needleMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xFF2D00,  // Ferrari red
                emissive: 0xFF2D00,
                emissiveIntensity: 0.8,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0
            });
            
            const needle = new THREE.Mesh(needleGeometry, needleMaterial);
            
            // Position needle at CENTER of gauge
            needle.position.set(...config.pos);
            needle.position.z += 0.05;
            
            // Calculate angle based on goal-based range
            const range = data.max - data.min;
            const normalizedValue = (data.current - data.min) / range;
            const sweepRange = Math.PI * 1.5; // 270 degrees
            const targetAngle = -Math.PI * 0.75 + (sweepRange * normalizedValue);
            
            // Start at configured lower position for dramatic reveal
            needle.rotation.z = config.needleStart;
            needle.castShadow = true;
            
            needle.userData = {
                isNeedle: true,
                metric: config.metric,
                targetAngle: targetAngle,
                baseAngle: targetAngle,
                interactive: true,
                startAngle: config.needleStart,
                hasAnimated: false,
                range: range,
                min: data.min
            };
            
            needles.push(needle);
            scene.add(needle);
            
            // Luxury center pivot
            const pivotGeometry = new THREE.CircleGeometry(0.025, 16);
            const pivotMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xD4AF37,  // Gold
                emissive: 0xD4AF37,
                emissiveIntensity: 0.3,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0
            });
            const pivot = new THREE.Mesh(pivotGeometry, pivotMaterial);
            pivot.position.set(...config.pos);
            pivot.position.z += 0.06;
            scene.add(pivot);
        }
        
        function createTickLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 64, 32);
            
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 16);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const labelGeometry = new THREE.PlaneGeometry(0.3, 0.15);
            const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
            labelMesh.position.set(x, y, z);
            scene.add(labelMesh);
        }
        
        function createDigitalDisplay(label, value, position, size) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(26, 26, 26, 0.9)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 256);
            
            // Border
            ctx.strokeStyle = '#D4AF37';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 492, 236);
            
            // Value
            ctx.fillStyle = '#00FF41';
            ctx.font = 'bold 48px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 255, 65, 0.5)';
            ctx.shadowBlur = 10;
            ctx.fillText(value + '%', 256, 128);
            
            // Label
            ctx.fillStyle = '#D4AF37';
            ctx.font = '20px Orbitron';
            ctx.shadowColor = 'rgba(212, 175, 55, 0.5)';
            ctx.shadowBlur = 5;
            ctx.fillText(label, 256, 200);
            
            const texture = new THREE.CanvasTexture(canvas);
            const displayMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1
            });
            
            const displayGeometry = new THREE.PlaneGeometry(size * 0.8, size * 0.4);
            const display = new THREE.Mesh(displayGeometry, displayMaterial);
            display.position.set(position[0], position[1] - size * 1.4, position[2] + 0.05);
            scene.add(display);
        }
        
        function startDramaticLoadSequence() {
            console.log('ðŸŽ¬ Starting dramatic load sequence...');
            
            // PHASE 1: Rapid spinning (0.5 seconds)
            needles.forEach((needle, i) => {
                gsap.to(needle.rotation, {
                    z: needle.userData.startAngle + Math.PI * 8, // Multiple spins
                    duration: 0.8,
                    ease: "power2.out",
                    delay: i * 0.1, // Stagger the needles
                    onComplete: () => {
                        // PHASE 2: Settle to target (1.5 seconds)
                        gsap.to(needle.rotation, {
                            z: needle.userData.targetAngle,
                            duration: 2.0,
                            ease: "elastic.out(1, 0.3)", // Bouncy settle
                            onComplete: () => {
                                // Mark as animated and start pulsation
                                needle.userData.hasAnimated = true;
                                needle.userData.baseAngle = needle.userData.targetAngle;
                                
                                // PHASE 3: Gentle breathing glow
                                gsap.to(needle.material, {
                                    emissiveIntensity: 0.6,
                                    duration: 1.5,
                                    yoyo: true,
                                    repeat: -1,
                                    ease: "sine.inOut"
                                });
                            }
                        });
                    }
                });
                
                // Scale animation for extra drama
                gsap.fromTo(needle.scale, 
                    { x: 0.1, y: 0.1, z: 1 },
                    { 
                        x: 1, y: 1, z: 1,
                        duration: 1.2,
                        ease: "back.out(1.7)",
                        delay: i * 0.1
                    }
                );
            });
            
            // Camera shake for impact
            const originalCameraZ = camera.position.z;
            gsap.to(camera.position, {
                z: originalCameraZ + 0.5,
                duration: 0.3,
                yoyo: true,
                repeat: 1,
                ease: "power2.inOut"
            });
            
            console.log('âœ¨ Load sequence complete - needles should be pulsating');
        }
        
        function setupInteractions() {
            // Mouse/touch tracking
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('click', onMouseClick);
            document.addEventListener('touchstart', onTouchStart);
            
            // Environment selector
            document.querySelectorAll('.env-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.env-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    createEnvironment(btn.dataset.env);
                });
            });
            
            // Custom cursor
            document.addEventListener('mousemove', (e) => {
                const cursor = document.getElementById('cursor');
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';
            });
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            checkNeedleHover();
        }
        
        function onTouchMove(event) {
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                checkNeedleHover();
            }
        }
        
        function onMouseClick(event) {
            handleNeedleInteraction();
        }
        
        function onTouchStart(event) {
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                handleNeedleInteraction();
            }
        }
        
        function checkNeedleHover() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(needles);
            
            // Reset all needles
            needles.forEach(needle => {
                if (needle.userData.isNeedle) {
                    needle.material.emissiveIntensity = 0.2;
                    needle.scale.set(1, 1, 1);
                }
            });
            
            // Highlight hovered needle
            if (intersects.length > 0) {
                const needle = intersects[0].object;
                needle.material.emissiveIntensity = 0.5;
                needle.scale.set(1.1, 1.1, 1.1);
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'none';
            }
        }
        
        function handleNeedleInteraction() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(needles);
            
            if (intersects.length > 0) {
                const needle = intersects[0].object;
                const metric = needle.userData.metric;
                const data = performanceData[metric];
                
                // Simulate target adjustment
                const newTarget = Math.min(data.max, data.target + 10);
                data.target = newTarget;
                
                // Animate needle to new target
                const newPercentage = newTarget / data.max;
                const newAngle = -Math.PI * 0.75 + (Math.PI * 1.5 * newPercentage);
                
                gsap.to(needle.rotation, {
                    z: newAngle,
                    duration: 1.5,
                    ease: "back.out(1.7)",
                    onUpdate: () => {
                        needle.userData.targetAngle = needle.rotation.z;
                    }
                });
                
                // Visual feedback
                gsap.to(needle.material, {
                    emissiveIntensity: 0.8,
                    duration: 0.3,
                    yoyo: true,
                    repeat: 3
                });
                
                console.log(`ðŸŽ¯ Target adjusted for ${metric}: ${newTarget}`);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate needles with precision movement (only after load animation)
            needles.forEach((needle, i) => {
                if (needle.userData.isNeedle && needle.userData.hasAnimated) {
                    // Gentle sweeping motion + subtle flutter
                    const sweep = Math.sin(time * 0.2 + i * 1.3) * 0.015; // Gentle sweep
                    const flutter = Math.sin(time * 0.8 + i * 2.1) * 0.003; // Micro flutter
                    needle.rotation.z = needle.userData.baseAngle + sweep + flutter;
                }
            });
            
            // Environment-specific animations
            if (currentEnvironment === 'space') {
                scene.children.forEach(child => {
                    if (child.userData.isEnvironment && child.type === 'Points') {
                        child.rotation.y += 0.0002;
                    }
                });
            }
            
            // Update performance indicator
            updatePerformanceIndicator();
            
            // Update HUD values
            updateHUD();
            
            renderer.render(scene, camera);
        }
        
        function updatePerformanceIndicator() {
            const overall = Object.values(performanceData).reduce((acc, data) => {
                return acc + (data.current / data.max);
            }, 0) / Object.keys(performanceData).length;
            
            const percentage = Math.round(overall * 100);
            document.getElementById('performance-value').textContent = percentage + '%';
            
            // Color coding
            const indicator = document.getElementById('performance-value');
            if (percentage >= 90) {
                indicator.style.color = '#00FF41';
            } else if (percentage >= 70) {
                indicator.style.color = '#FFD700';
            } else {
                indicator.style.color = '#FF4444';
            }
        }
        
        function updateGaugeFaces() {
            scene.children.forEach(child => {
                if (child.userData.isGaugeFace && child.userData.metric) {
                    const data = performanceData[child.userData.metric];
                    const config = child.userData.config;
                    if (data) {
                        const canvas = child.userData.canvas;
                        const ctx = child.userData.ctx;
                        const size = 512;
                        
                        // Clear canvas
                        ctx.clearRect(0, 0, size, size);
                        
                        // Ferrari/Cartier luxury gradient
                        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                        gradient.addColorStop(0, '#1a1a1a');
                        gradient.addColorStop(0.4, '#2d2d2d');
                        gradient.addColorStop(0.8, '#404040');
                        gradient.addColorStop(1, '#0d0d0d');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add subtle inner shadow
                        ctx.shadowColor = 'rgba(0,0,0,0.2)';
                        ctx.shadowBlur = 20;
                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // Draw tick marks and numbers
                        const maxValue = data.max;
                        for (let i = 0; i <= 10; i++) {
                            const percentage = i / 10;
                            const angle = -Math.PI * 0.75 + (Math.PI * 1.5 * percentage);
                            const isMajor = i % 2 === 0;
                            
                            // Tick marks
                            const tickStart = isMajor ? 0.75 : 0.8;
                            const tickEnd = 0.9;
                            const startX = size/2 + Math.cos(angle) * (size/2 * tickStart);
                            const startY = size/2 + Math.sin(angle) * (size/2 * tickStart);
                            const endX = size/2 + Math.cos(angle) * (size/2 * tickEnd);
                            const endY = size/2 + Math.sin(angle) * (size/2 * tickEnd);
                            
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = isMajor ? 3 : 1;
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                            
                            // Numbers for major ticks
                            if (isMajor) {
                                const value = Math.round(percentage * maxValue);
                                const labelRadius = 0.65;
                                const labelX = size/2 + Math.cos(angle) * (size/2 * labelRadius);
                                const labelY = size/2 + Math.sin(angle) * (size/2 * labelRadius);
                                
                                ctx.fillStyle = '#000000';
                                ctx.font = 'bold 24px Orbitron';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(value.toString(), labelX, labelY);
                            }
                        }
                        
                        // Center area with large value display
                        const currentValue = Math.round(data.current);
                        
                        // Background circle for center display
                        ctx.fillStyle = 'rgba(0,0,0,0.8)';
                        ctx.beginPath();
                        ctx.arc(size/2, size/2, size/2 * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glowing border around center
                        ctx.strokeStyle = '#D4AF37';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#D4AF37';
                        ctx.shadowBlur = 15;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // Performance-based value color (Ferrari red accent)
                        let valueColor = '#FF2D00'; // Ferrari red default
                        const targetDiff = Math.abs(currentValue - data.target);
                        if (targetDiff <= 5) valueColor = '#D4AF37';      // Gold (on target)
                        else if (targetDiff <= 15) valueColor = '#E5E4E2'; // Platinum (close)
                        else if (currentValue > data.target) valueColor = '#32CD32'; // Green (exceeding)
                        
                        ctx.fillStyle = valueColor;
                        ctx.font = 'bold 64px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = valueColor;
                        ctx.shadowBlur = 20;
                        ctx.fillText(currentValue.toString(), size/2, size/2 - 20);
                        
                        // Unit symbol
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 24px Orbitron';
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 10;
                        ctx.fillText(data.unit, size/2, size/2 + 20);
                        
                        // Metric label at bottom
                        ctx.fillStyle = '#D4AF37';
                        ctx.font = 'bold 18px Orbitron';
                        ctx.shadowColor = '#D4AF37';
                        ctx.shadowBlur = 8;
                        ctx.fillText(config.label, size/2, size/2 + 60);
                        ctx.shadowBlur = 0;
                        
                        // Update texture
                        child.userData.texture.needsUpdate = true;
                    }
                }
            });
        }

        function updateHUD() {
            // Simulate real-time data updates
            if (Math.random() < 0.01) { // More frequent updates
                Object.keys(performanceData).forEach(key => {
                    const data = performanceData[key];
                    const variation = (Math.random() - 0.5) * 1; // Smaller variations
                    data.current = Math.max(0, Math.min(data.max, data.current + variation));
                });
                
                // Update HUD display
                document.getElementById('revenue-velocity').textContent = '$' + Math.round(performanceData.revenueVelocity.current * 10) + 'K/mo';
                document.getElementById('quota-achievement').textContent = Math.round(performanceData.quotaAchievement.current) + '%';
                document.getElementById('pipeline-health').textContent = Math.round(performanceData.pipelineHealth.current) + '%';
                document.getElementById('win-rate').textContent = Math.round(performanceData.winRate.current) + '%';
                document.getElementById('activity-score').textContent = Math.round(performanceData.activityScore.current);
                document.getElementById('team-ranking').textContent = '#' + Math.round(performanceData.teamRanking.current);
                
                // Update gauge faces
                updateGaugeFaces();
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when ready
        window.addEventListener('load', () => {
            if (typeof THREE !== 'undefined' && typeof gsap !== 'undefined') {
                init();
            } else {
                console.error('Required libraries not loaded');
            }
        });
        
        // Prevent context menu on touch devices
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>